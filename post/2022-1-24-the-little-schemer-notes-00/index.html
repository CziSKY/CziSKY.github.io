<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
<title>The Little Schemer 笔记 —— 零 | </title>


  <link rel="shortcut icon" type="image/png" href="&#x2F;images&#x2F;favicon.png">
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <link id="stylesheet" rel="stylesheet" type="text/css" href="/dark.css">

  <script type="text/javascript" src="/js/theme.js"></script>

</head>

<div class="header">
  <div class="site_title">
    <p><a href="/"><img src="https:&#x2F;&#x2F;czisky.github.io&#x2F;images&#x2F;logo.png" alt=""
          width="70" height=auto></a></p>
    <p><a href="/">&nbsp;</a></p>
  </div>
  <div class="menu">
    <a href="/post">>archives</a>
    &nbsp;<a href="/about">>about</a>
  </div>
</div>

<body onload="getTheme()">
  <section class="section">
    <div class="container">
      
<p>
  <div class="title_postpage">The Little Schemer 笔记 —— 零</div>
</p>
<p>
  <div class="date_postpage">2023-01-24</div>
  <div class="taxonomies_postpage">
  
      
      <a href="https://czisky.github.io/categories/notes/">/notes</a>
      
  
  
      
      &emsp;<a href="https://czisky.github.io/tags/programming-language/">#programming language</a>
      
      &emsp;<a href="https://czisky.github.io/tags/scheme/">#scheme</a>
      
  
  </div>
</p>

<p>
  <blockquote>
<p>如果你的朋友说话后面经常带 <code>（</code>，那他就已经掌握了 Scheme 这门语言的精髓。（并不是，我瞎说的。我只是想开个玩笑</p>
</blockquote>
<h1 id="toys">Toys</h1>
<p><code>Atom</code> 和 <code>List</code> 都属于 <code>S-Expression</code>，<code>List</code> 是由 <code>S-Expression</code> 构成的集合（这意味着你可以构成 <code>((abc) ((cba)), ())</code> 这样的 <code>List</code>），而 <code>Atom</code> 可以看作是单个元素。例如 <code>abc</code>、<code>True</code>
和 <code>123</code> 都是 <code>Atom</code>。</p>
<ul>
<li><code>()</code> 也是一个 <code>List</code>，被称为 <code>Null List</code>。</li>
<li>在命名上，通过操作符 <code>'</code> (Quote) 号来区分对象是否是一个 <code>S-Expression</code> 还是一个可被执行的函数体。例如 <code>(quote (+ 2 2))</code> 或者 <code>'(+ 2 2)</code> 是一个 <code>List</code>，而不会被求值 (Evaluate) 成 <code>4</code>。</li>
</ul>
<p>车 (<code>car</code>) 和 成都人 (<code>cdr</code>)：</p>
<ul>
<li><code>(car l)</code> 表示取 <code>l</code> 这个 <code>List</code> 中的头元素，就像 Haskell 的 <code>head</code> 函数。例如：<code>(car '((a b c) x y z)) =&gt; '(a b c)</code></li>
<li><code>(cdr l)</code> 表示取 <code>l</code> 这个 <code>List</code> 中除了头元素的所有元素，就像 Haskell 的 <code>tail</code> 函数。当 <code>List</code> 只有一个元素时返回 <code>()</code>。例如：<code>(cdr '((a b c) x y z)) =&gt; '(x y z)</code>。</li>
</ul>
<p>其中 <code>car</code> 和 <code>cdr</code> 都不能对 <code>()</code> 或 <code>Atom</code> 进行操作。</p>
<p><code>(cons x l)</code> 表示把一个元素加在 <code>l</code> 的头部。就像 Haskell 的 <code>:</code> 操作符。例如 <code>(cons 'a (car '((b) c d))) =&gt; '(a b)</code>。第一个参数为 <code>S-Expression</code>，第二个参数必须为 <code>List</code>。</p>
<p>任意 <code>'a</code> 为 <code>S-Expression</code>，<code>'b</code> 为 <code>List</code>，可推出：</p>
<ul>
<li><code>(car (cons 'a 'b)) =&gt; 'a</code></li>
<li><code>(cdr (cons 'a 'b)) =&gt; 'b</code></li>
</ul>
<p><code>(null? l)</code> 表示参数是否为 <code>Null List</code>，其中 <code>l</code> 必须为 <code>List</code>。例：<code>(null? '(a)) =&gt; #F</code></p>
<p><code>(atom? s)</code> 表示参数是否为 <code>Atom</code>，其中 <code>s</code> 为 <code>S-Expression</code>。它的定义如下：</p>
<pre data-lang="scheme" class="language-scheme "><code class="language-scheme" data-lang="scheme">(define atom?
  (lambda (x)
    (and (not (pair? x))
         (not (null? x)))))
</code></pre>
<p>将 <code>and</code> 翻译成 <code>&amp;&amp;</code>，<code>not</code> 翻译成 <code>!</code> (即颠倒布尔值)。我就能理解这个定义了：对于参数 <code>x</code>，如果它既不满足 <code>pair? x</code> 的条件（这里没有给出来）也不是 <code>Null List</code>
，那它则是一个 <code>Atom</code>。</p>
<p><code>(eq? a b)</code> 用来判断两个 <code>Atom</code> 参数是否相等，<strong>其中两个参数不可以是数字</strong>。</p>
<h1 id="do-it-do-it-again-and-again-and-again">Do It, Do It Again, and Again, and Again…</h1>
<p><code>lat</code> 表示为一个只有 <code>Atom</code> 的集合，而 <code>lat? l</code> 可以判断参数 <code>List</code> 是否满足这个条件。<code>lat?</code> 的定义：</p>
<pre data-lang="scheme" class="language-scheme "><code class="language-scheme" data-lang="scheme">(define lat?
  (lambda (l)
    (cond
     ((null? l) #t)
     ((atom? (car l)) (lat? (cdr l)))
     (else #f))))
</code></pre>
<p>它是用我的老朋友递归实现的，在 Haskell 系列教程和 CS61A 我就已经见过 114514 次了。为了帮助理解我决定用简单的语言再解释一遍：</p>
<ul>
<li>它接收一个参数 <code>l</code>，必须为 <code>List</code>。主体由两个条件语句组成。</li>
<li>第一个条件即判断 <code>l</code> 是否为一个空集合 <code>Null List</code>。如果是的话即返回 <code>True</code>。</li>
<li>第二个条件判断 <code>l</code> 的第一个元素是否是 <code>Atom</code>。
<ul>
<li>如果是 <code>Atom</code>，即把移除头元素的集合再递给 <code>lat?</code> 进行调用。每次递归调用集合都会少去一个头元素，如果这个 <code>List</code> 都由 <code>Atom</code>
组成的话，最后一次递归调用即会触发前面第一个条件。则返回 <code>True</code>。</li>
<li>如果某一个元素为 <code>List</code>，则会跳转到下面 else 的部分，即返回 <code>False</code>。</li>
</ul>
</li>
</ul>
<p>同时，这里的 <code>cond</code> 是 Pattern Matching。</p>
<p><code>(or? a b)</code> 接收两个布尔值参数，类似于常见编程语言中的 <code>||</code>。</p>
<p><code>(member? a lat)</code> 来表示参数 <code>a</code> 是否为 <code>List lat</code> 中的一部分 (Contain)，它的实现同样使用了递归，定义如下：</p>
<pre data-lang="scheme" class="language-scheme "><code class="language-scheme" data-lang="scheme">(define member?
  (lambda (a lat)
    (cond
     ((null? lat) #f)
     (else (or (eq? (car lat) a) (member? a (cdr lat)))))))
</code></pre>
<h1 id="cons-the-magnificent">Cons the Magnificent</h1>
<p><code>(rember a lat)</code> 表示从 <code>List lat</code> 里面移除第一个存在的 <code>a</code> 元素，定义如下：</p>
<pre data-lang="scheme" class="language-scheme "><code class="language-scheme" data-lang="scheme">(define rember
  (lambda (a lat)
    (cond
     ((null? lat) (quote ()))
     ((eq? a (car lat)) (cdr lat))
     (else (cons (car lat)
                 (rember a (cdr lat)))))))
</code></pre>
<p><code>(firsts l)</code> 表示取出 <code>List l</code> 中的每一个元素 <code>List</code> 中的第一个元素构成集合，定义如下：</p>
<pre data-lang="scheme" class="language-scheme "><code class="language-scheme" data-lang="scheme">(define firsts
  (lambda (l)
    (cond
     ((null? l) (quote ()))
     (else (cons (car (car l)) (firsts (cdr l)))))))
</code></pre>
<p><code>(cons (car (car l)) (firsts (cdr l)))</code> 的前部分 <code>cons (car (car l))</code> 可以称为 <code>Typical Element</code>。后半部分 <code>(firsts (cdr l))</code> 被称成 <code>Natural Recursion</code>。这种一种结构化思考递归程序的方式，按我自己的话来说这种方式可以提醒我们确认函数什么时候终止。（即什么时候该停止递归返回结果）</p>
<p>比如说针对 <code>((a b) (c d) (e f))</code>，它最开始的 <code>Typical Element</code> 只是 <code>'a</code>（第一次执行）。然后通过 <code>Natural Recursion</code> 又求出 <code>Typical Element</code> <code>'c</code> 和 <code>'e</code>。最后一次结束递归返回 <code>'()</code>。通过 <code>cons</code> 又把它们合在一起成为了 <code>'(a c e)</code>。</p>
<p><img src="http://i.stack.imgur.com/QhBcl.png" alt="" /></p>
<p><code>(insertR a b lat)</code> 表示在 <code>List lat</code> 里，把 <code>Atom a</code> 插入到 <code>Atom b</code> 后。如 <code>(insertR 'a 'b '(c d b)) =&gt; '(c d b a)</code>。<code>(insertL a b lat)</code> 是它的对偶，即将 <code>Atom a</code> 插入到 <code>Atom b</code> 前面，定义如下：</p>
<pre data-lang="scheme" class="language-scheme "><code class="language-scheme" data-lang="scheme">(define insertR
  (lambda (a b lat)
    (cond
     ((null? lat) (quote ()))
     ((eq? b (car lat)) (cons b
                              (cons a (cdr lat))))
     (else (cons (car lat)
                 (insertR a b (cdr lat)))))))
</code></pre>
<pre data-lang="scheme" class="language-scheme "><code class="language-scheme" data-lang="scheme">(define insertL
  (lambda (a b lat)
    (cond
     ((null? lat) (quote ())))
     ((eq? b (car lat)) (cons a lat))
     (else (cons (car lat)
                 (insertL a b (cdr lat))))))
</code></pre>
<p><code>(subst a b lat)</code> 表示在 <code>List lat</code> 中，用 <code>Atom a</code> 替代第一个出现的 <code>Atom b</code>。如 <code>(subst 'a 'b '(c b)) =&gt; '(c a)</code>，定义如下：</p>
<pre data-lang="scheme" class="language-scheme "><code class="language-scheme" data-lang="scheme">(define subst
  (lambda (a b lat)
    (cond
     ((null? lat) (quote ()))
     ((eq? b (car lat)) (cons a (cdr lat)))
     (else (cons (car lat)
                 (subst a b (cdr lat)))))))
</code></pre>
<p><code>(subst2 a b c lat)</code> 表示在 <code>List lat</code> 中，用 <code>Atom a</code> 替代第一个出现的 <code>Atom b</code> 或 <code>Atom c</code> 。如 <code>(subst2 'a 'b '(c b)) =&gt; '(c a)</code>，定义如下：</p>
<pre data-lang="scheme" class="language-scheme "><code class="language-scheme" data-lang="scheme">(define subst2
  (lambda (a b c lat)
    (cond
     ((null? lat) (quote ()))
     ((or (eq? b (car lat))
          (eq? c (car lat))) (cons a (cdr lat)))
     (else (cons (car lat)
                 (subst2 a b c (cdr lat)))))))
</code></pre>
<p><code>(multirember a lat)</code> 表示在 <code>List lat</code> 中删除所有的 <code>Atom a</code>。定义如下：</p>
<pre data-lang="scheme" class="language-scheme "><code class="language-scheme" data-lang="scheme">(define multirember
  (lambda (a lat)
    (cond
     ((null? lat) (quote ()))
     ((eq? a (car lat)) (multirember a (cdr lat)))
     (else (cons (car lat)
                 (multirember a (cdr lat)))))))
</code></pre>
<p><code>(multiinsertR a b lat)</code> 表示在 <code>List lat</code> 中，在所有的 <code>Atom b</code> 后面插入一个 <code>Atom a</code>。定义如下：</p>
<pre data-lang="scheme" class="language-scheme "><code class="language-scheme" data-lang="scheme">(define multiinsertR
  (lambda (a b lat)
    (cond
     ((null? lat) (quote ()))
     ((eq? b (car lat)) (cons b
                              (cons a (multiinsertR a b (cdr lat)))))
     (else (cons (car lat)
                 (multiinsertR a b (cdr lat)))))))
</code></pre>
<p><code>(multiinsertL a b lat)</code> 表示在 <code>List lat</code> 中，在所有的 <code>Atom b</code> 前面插入一个 <code>Atom a</code>。定义如下：</p>
<pre data-lang="scheme" class="language-scheme "><code class="language-scheme" data-lang="scheme">(define multiinsertL
  (lambda (a b lat)
    (cond
     ((null? lat) (quote ()))
     ((eq? b (car lat)) (cons a (cons b (multiinsertL a b (cdr lat)))))
     (else (cons (car lat)
                 (multiinsertL a b (cdr lat)))))))
</code></pre>
<p><code>(multisubst a b lat)</code> 表示在 <code>List lat</code> 中，把所有的 <code>Atom b</code> 替换成 <code>Atom a</code>。定义如下：</p>
<pre data-lang="scheme" class="language-scheme "><code class="language-scheme" data-lang="scheme">(define multisubst
  (lambda (a b lat)
    (cond
     ((null? lat) (quote ()))
     ((eq? b (car lat)) (cons a (multisubst a b (cdr lat))))
     (else (cons (car lat)
                 (multisubst a b (cdr lat)))))))
</code></pre>

</p>




    </div>
  </section>
</body>

<div class="footer">
  <a href="/"></a>&emsp;&copy; 闲蛋 (kirraObj)<br>
  powered by <a href="https://www.getzola.org/">Zola</a>, theme <a
    href="https://github.com/kyoheiu/emily_zola_theme">emily</a>.
</div>

</html>
