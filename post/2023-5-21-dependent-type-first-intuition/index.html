<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
<title>了解 Dependent Type | </title>


  <link rel="shortcut icon" type="image/png" href="&#x2F;images&#x2F;favicon.png">
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <link id="stylesheet" rel="stylesheet" type="text/css" href="/dark.css">

  <script type="text/javascript" src="/js/theme.js"></script>

</head>

<div class="header">
  <div class="site_title">
    <p><a href="/"><img src="https:&#x2F;&#x2F;czisky.github.io&#x2F;images&#x2F;logo.png" alt=""
          width="70" height=auto></a></p>
    <p><a href="/">&nbsp;</a></p>
  </div>
  <div class="menu">
    <a href="/post">>archives</a>
    &nbsp;<a href="/about">>about</a>
  </div>
</div>

<body onload="getTheme()">
  <section class="section">
    <div class="container">
      
<p>
  <div class="title_postpage">了解 Dependent Type</div>
</p>
<p>
  <div class="date_postpage">2023-05-21</div>
  <div class="taxonomies_postpage">
  
      
      <a href="https://czisky.github.io/categories/garbage/">/garbage</a>
      
  
  
      
      &emsp;<a href="https://czisky.github.io/tags/programming-language/">#programming language</a>
      
  
  </div>
</p>

<p>
  <blockquote>
<p>前几天给 <a href="https://github.com/anqurvanillapy">Anqur</a> 大佬的 <code>RowScript</code> 提了个 Issue，然后 QQ 突然被加好友并被介绍了最简单的依值类型 (Dependent Type) 是什么样的。所以归纳整理产出点垃圾强化下印象。</p>
</blockquote>
<blockquote>
<p>在这里也安利一下，<a href="https://github.com/rowscript/rowscript">RowScript</a> 是还在前期开发中 (In heavy development)，能转译到 JavaScript 的纯函数式编程语言。目标用户群体是 JS 社区。</p>
</blockquote>
<p>以 Kotlin 举例，我们能在常见的静态类型编程语言写出这种东西：</p>
<pre data-lang="kotlin" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin">fun &lt;T&gt; id(t: T): T = t
</code></pre>
<p>意思是说，它能够接收一个任何类型 (即泛型 T) 的参数然后返回参数本身，例 <code>id(114514)</code> 返回 <code>114514</code>。</p>
<p>用 Haskell 重写一下：</p>
<pre data-lang="haskell" class="language-haskell "><code class="language-haskell" data-lang="haskell">id :: forall T. T -&gt; T
id x = x
</code></pre>
<p>在 Haskell 中，该函数显式标注的类型 (或类型签名) 可以让我们很直观的观察该函数的性质。实际上，System-F 明确规定了类型是分为 <code>Value Type</code> 跟 <code>Type Scheme</code> 的。</p>
<p>拿以上例子来说，<code>forall T.</code> 就是一个 <code>Type Scheme</code>。它将输入的类型参数化作为一个占位符，并让后面的 <code>Value Type</code> 就是 <code>T -&gt; T</code> 用上这个参数 (类型)。</p>
<p>但在 Dependent Type 中，我们没有 <code>Value Type</code> 和 <code>Type Scheme</code> 。假如有一个支持 Dependent Type 的语言，上述函数的类型应该会被改写成这样子：</p>
<pre><code>(T : Type) -&gt; T -&gt; T
</code></pre>
<p>在这里可以将 <code>(T : Type)</code> 理解为约束传进来的 <code>T</code> 为任意类型。(就跟 Kotlin 中的 <code>&lt;T&gt;</code> 或者 Haskell 中的 <code>forall T.</code> 很像) ，实际上这个 <code>Type</code> 是一个叫 <code>Universe</code> 的东西。意为所有类型的类型 (Type of type)。</p>
<p>然而在上述的表示中，其实 <code>T -&gt; T</code> 的定义是加了语法糖的。在去糖之后它长这个样子：</p>
<pre><code>(T : Type) -&gt; (a : T) -&gt; T
</code></pre>
<p>你可能看着会很懵逼，为什么第二个 <code>T</code> 也能存在参数？但谜底在此时揭晓了，在 Dependent Type 中你可以写出任意类型的定义，也可以写出值的定义。但是它们都算某种表达式 (Expression) 的定义。</p>
<pre><code>let ID : Type = (T : Type) -&gt; (a : T) -&gt; T
</code></pre>
<p>我们将类型或是这个表达式绑在了 <code>F</code> 上，它称为 <code>Function Type</code> 或 <code>Dependent Function Type</code> 或 <code>Pi Type</code>。同样的，有类型也要有值。可以理解为我们可以编写对应的实现函数 (Lambda)。</p>
<pre><code>let ID : Type = (T : Type) -&gt; (a : T) -&gt; T

let id : ID = lambda (T : Type) . lambda (a : T) . a
</code></pre>
<p>这就是依值类型 (Dependent Type)。就像我们日常编程使用函数中参数定义了什么，那么函数的内部就能使用那个参数。Dependent Type 多了一个你在 <code>Function Type</code> 的 &quot;参数&quot; 里定义了什么，那么在它的 Body 中就能用那个参数。</p>
<h2 id="pushing-door-to-the-future">Pushing door to the future</h2>
<p>注意，<code>(T : Type)</code> 在 Dependent Type 中是一个参数，在没有编译器额外 Handling 的情况下调用该函数需要传入一个类型作为实参，例 <code>f number 114514</code></p>
<p>但你可以实现类型推导：<a href="https://zhuanlan.zhihu.com/p/74410702">dependent type 下的类型推导 (meta variables)
</a>。</p>

</p>




    </div>
  </section>
</body>

<div class="footer">
  <a href="/"></a>&emsp;&copy; 闲蛋 (kirraObj)<br>
  powered by <a href="https://www.getzola.org/">Zola</a>, theme <a
    href="https://github.com/kyoheiu/emily_zola_theme">emily</a>.
</div>

</html>
